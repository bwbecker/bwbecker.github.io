<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hard-Won Scala &#43; Play</title>
    <link>http://example.org/</link>
    <description>Recent content on Hard-Won Scala &#43; Play</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 08 Feb 2018 08:56:48 -0500</lastBuildDate>
    
	<atom:link href="http://example.org/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Silhouette&#43;CAS</title>
      <link>http://example.org/posts/silhouette&#43;cas/</link>
      <pubDate>Thu, 08 Feb 2018 08:56:48 -0500</pubDate>
      
      <guid>http://example.org/posts/silhouette&#43;cas/</guid>
      <description>I&amp;rsquo;ve been using the excellent Silhouette authentication library for my Play! project. When I first started using it there was no support for CAS. I rolled my own support.
Silhouette now supports CAS much more directly, but none of the seed projects show it integrated in. Part of the difficulty of including it in a seed project is that there aren&amp;rsquo;t any public social providers such as Facebook or Google to demonstrate it.</description>
    </item>
    
    <item>
      <title>Twitter Typeahead</title>
      <link>http://example.org/posts/submit-on-enter-with-twitter-typeahead/</link>
      <pubDate>Sat, 29 Aug 2015 09:00:45 -0500</pubDate>
      
      <guid>http://example.org/posts/submit-on-enter-with-twitter-typeahead/</guid>
      <description>Twitter&amp;rsquo;s Typeahead widget adds suggestions to an input field based on what the user has already typed. We&amp;rsquo;re all familiar with such widgets from Google searches, for example.
I thought it would be easy to set up and get going. Indeed, seeing first (promising) results went really quickly. But then I spent the rest of the day figuring out the corner cases that weren&amp;rsquo;t handled and Dr. Google didn&amp;rsquo;t provide answers for.</description>
    </item>
    
    <item>
      <title>Painful Ide Switch</title>
      <link>http://example.org/posts/painful-ide-switch/</link>
      <pubDate>Thu, 28 May 2015 09:00:22 -0500</pubDate>
      
      <guid>http://example.org/posts/painful-ide-switch/</guid>
      <description>I&amp;rsquo;ve been using Eclipse for my Play! + Scala development, but frustration reached the tipping point and I decided to give IDEA a try. It had been highly recommended by fellow developers at a Scala Meetup (now defunct, sadly). The conversion process has been painful, with some hard-won lessons to report.
So, what drove me around the bend with Eclipse? One more bout with it reporting many false positive compilation errors with no easy way to reset things that I could find.</description>
    </item>
    
    <item>
      <title>Postgres Enums and Anorm, Part 2</title>
      <link>http://example.org/posts/postgres-enums-and-anorm-pt2/</link>
      <pubDate>Wed, 06 May 2015 08:59:49 -0500</pubDate>
      
      <guid>http://example.org/posts/postgres-enums-and-anorm-pt2/</guid>
      <description>I went to implement my enumerations discoveries as chronicalled in Postgres Enums and Anorm and realized anew something that had niggled away in the back of my brain: I&amp;rsquo;m working with data from a legacy database and most of the enumerations are indecipherable. Many of the enumerations are like this:
CREATE TYPE _quest.quest_instruction_mode AS ENUM (&#39;P&#39;, &#39;CO&#39;);  where &amp;lsquo;P&amp;rsquo; stands for (as far as we can tell!) &amp;ldquo;in-Person&amp;rdquo; and &amp;lsquo;CO&amp;rsquo; stands for &amp;ldquo;Course-Online&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Using Anorm without Play</title>
      <link>http://example.org/posts/anorm-without-play/</link>
      <pubDate>Tue, 05 May 2015 09:05:05 -0500</pubDate>
      
      <guid>http://example.org/posts/anorm-without-play/</guid>
      <description>Ever want to use Anorm to access a database without all the overhead of Play?
I did in my previous post where I played with Postgres enumerations. Here&amp;rsquo;s the code I used.
It has a couple of features:
 It reads the .pg_service.conf and .pgpass files from your home directory to find a service definition and the appropriate passwords to use for the connection. This keeps passwords and such out of your code and out of your repository.</description>
    </item>
    
    <item>
      <title>Postgres Enums and Anorm</title>
      <link>http://example.org/posts/postgres-enums-anorm/</link>
      <pubDate>Tue, 05 May 2015 08:59:49 -0500</pubDate>
      
      <guid>http://example.org/posts/postgres-enums-anorm/</guid>
      <description>Types are a wonderful thing in programming languages. It&amp;rsquo;s the main reason I&amp;rsquo;m using Scala. Having the compiler do a proof that at least part of my program is correct is a huge advantage over a dynamically typed language.
Databases can also make use of types &amp;ndash; with similar advantages. In my current project we&amp;rsquo;ve been receiving data from a database that does not use types or other constraints that are the hallmark of modern database design.</description>
    </item>
    
    <item>
      <title>Hard-Won Intro</title>
      <link>http://example.org/posts/hard_won_intro/</link>
      <pubDate>Tue, 05 May 2015 08:59:36 -0500</pubDate>
      
      <guid>http://example.org/posts/hard_won_intro/</guid>
      <description>I&amp;rsquo;m doing a lot of development in Scala + Play these days. I often come up against a problem with a &amp;ldquo;hard won&amp;rdquo; solution. It might be a fundamental misunderstanding on my part, something I just haven&amp;rsquo;t run into before, or where Googling isn&amp;rsquo;t as helpful as it often is. Regardless, the solution came at some pain to myself. To help make that hard won solution less painful, I&amp;rsquo;m posting here to remind me and to help others.</description>
    </item>
    
  </channel>
</rss>