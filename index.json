[
{
	"uri": "http://example.org/posts/silhouette+cas/",
	"title": "Silhouette+CAS",
	"tags": [],
	"description": "",
	"content": " I\u0026rsquo;ve been using the excellent Silhouette authentication library for my Play! project. When I first started using it there was no support for CAS. I rolled my own support.\nSilhouette now supports CAS much more directly, but none of the seed projects show it integrated in. Part of the difficulty of including it in a seed project is that there aren\u0026rsquo;t any public social providers such as Facebook or Google to demonstrate it.\nSo here\u0026rsquo;s what I did to get it working with our institution\u0026rsquo;s CAS server, starting with the Silhouette Seed Template.\nGetting Going  Clone the seed project: git clone https://github.com/mohiva/play-silhouette-seed.git play-siloutte-cas-seed.\n Note the instructions in the seed project\u0026rsquo;s tutorial to update the code to run locally:  In the application.conf file, set play.mailer.mock = true (this was already true for me). In the SignUpController at about line 95 set activated = true. If you\u0026rsquo;re using CAS, the User class will likely be modified to eliminate this field.  Make a quick and dirty CAS icon by duplicating and editing one of the existing icons in public/images/providers/. The project will display this icon. Clicking it will redirect to CAS. Name your new icon cas.png.  The Build File Add the library dependency for play-silhouette-cas to build.sbt: \u0026quot;com.mohiva\u0026quot; %% \u0026quot;play-silhouette-cas\u0026quot; % \u0026quot;5.0.0\u0026quot;,. Change the name of the project and any other personal preferences.\nAt one point in the protocol CAS demands that the connection to your server be over https. So add the following:\njavaOptions ++= Seq( \u0026quot;-Dhttp.port=9000\u0026quot;, \u0026quot;-Dhttps.port=9443\u0026quot; )  Logging I found enabling the logging to be a very helpful step in debugging the interactions with our CAS server. I copied the default logback.xml and added \u0026lt;logger name=\u0026quot;com.mohiva.play.silhouette\u0026quot; level=\u0026quot;DEBUG\u0026quot; /\u0026gt;.\nConfig Parameters Add something similar to this to silhouette.conf:\n # CAS provideer cas.casURL=\u0026quot;https://cas.uwaterloo.ca/cas\u0026quot; cas.redirectURL=\u0026quot;https://localhost:9443/authenticate/cas\u0026quot; cas.protocol=\u0026quot;CAS10\u0026quot;  The default protocol is CAS30. Our institution is apparently using CAS10; it took some trial and error and looking at logs to figure that out. Also pay attention to the casURL. Yours could very well be different.\nTackling SilhouetteModule SilhouetteModule is where all the heavy lifting takes place to integrate CAS into the seed project.\nAdd import com.mohiva.play.silhouette.impl.providers.CasProvider.\nIn provideSocialProviderRegistry add casProvider: CasProvider as a parameter and pass it to the SocialProviderRegistry constructor.\nAdd a CasProvider provider for Guice:\n/** * Provides the CAS provider. * */ @Provides def provideCasProvider( httpLayer: HTTPLayer, configuration: Configuration ): CasProvider = { import net.ceedubs.ficus.readers.EnumerationReader._ val settings = configuration.underlying.as[CasSettings](\u0026quot;silhouette.cas\u0026quot;) val client = new CasClient(settings) new CasProvider(httpLayer, settings, client) }  Add a provision for a CAS AuthInfoRepository by adjusting the provideAuthInfoRepository definition:\ndef provideAuthInfoRepository( passwordInfoDAO: DelegableAuthInfoDAO[PasswordInfo], oauth1InfoDAO: DelegableAuthInfoDAO[OAuth1Info], oauth2InfoDAO: DelegableAuthInfoDAO[OAuth2Info], openIDInfoDAO: DelegableAuthInfoDAO[OpenIDInfo], casInfoDAO: DelegableAuthInfoDAO[CasInfo]): AuthInfoRepository = { new DelegableAuthInfoRepository(passwordInfoDAO, oauth1InfoDAO, oauth2InfoDAO, openIDInfoDAO, casInfoDAO) }  Add a binding in the configure method:\nbind[DelegableAuthInfoDAO[CasInfo]].toInstance(new InMemoryAuthInfoDAO[CasInfo])  At this point sbt ~run should successfully compile and run the program. Pointing a browser at localhost:9000 should display the signin page that includes your CAS icon. Clicking that icon should redirect you to the CAS server. Log in and get redirected back to the authenticate controller. It finishes the authentication procedure and then redirects you to the site\u0026rsquo;s home page.\nOur CAS server only returns the userid, which isn\u0026rsquo;t displayed on the home page. Add the following to home.scala.html to display the userid.\n\u0026lt;div class=\u0026quot;row\u0026quot;\u0026gt; \u0026lt;p class=\u0026quot;col-md-6\u0026quot;\u0026gt;\u0026lt;strong\u0026gt;userid:\u0026lt;/strong\u0026gt;\u0026lt;/p\u0026gt;\u0026lt;p class=\u0026quot;col-md-6\u0026quot;\u0026gt;@user.loginInfo.providerKey\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt;  "
},
{
	"uri": "http://example.org/posts/submit-on-enter-with-twitter-typeahead/",
	"title": "Twitter Typeahead",
	"tags": [],
	"description": "",
	"content": "Twitter\u0026rsquo;s Typeahead widget adds suggestions to an input field based on what the user has already typed. We\u0026rsquo;re all familiar with such widgets from Google searches, for example.\nI thought it would be easy to set up and get going. Indeed, seeing first (promising) results went really quickly. But then I spent the rest of the day figuring out the corner cases that weren\u0026rsquo;t handled and Dr. Google didn\u0026rsquo;t provide answers for.\nUpdate: At some point I grew frustrated with Typeahead again and switched to jQuery-Autocomplete.\nThe Typeahead use case seems to be one input field in a larger form. It helps find the correct value for that field but something else in the form handles the submission.\nMy use case is a different but very common one \u0026ndash; search. The form has a single search field used to search for, in my case, a person. The search could be on one of the unique identifiers (a number or alphameric userid) or based on a name. The name is where the typeahead is needed. Once the user has found the right person (perhaps by selecting off the typeahead list), hit enter and it\u0026rsquo;s submitted.\nThe hard part was getting it to play nicely with the keyboard: Submit on enter, submit the correct suggestion if chosen with the arrow keys, avoid resubmitting contents the are already in the form from a previous submission.\nFinally, when the submission occurs it should be with the userid for uniqueness. Each user\u0026rsquo;s userid is returned from my suggestion web service along with the name.\nI think the basic issue is Typeahead\u0026rsquo;s event model and API is incomplete. I kept looking in the documentation for two things:\n A method to get the current suggestion An event that says \u0026ldquo;Here\u0026rsquo;s the suggestion that was chosen\u0026rdquo;  I found the typeahead:change event to be useless. I could not figure out how it gets triggered.\nThe typeahead:select and typeahead:autocomplete were useful for when the user hit tab or clicked in another field. But not when they hit the enter key.\nMy suggestions web service returns json lists such as:\n[ { \u0026quot;surname\u0026quot;: \u0026quot;Bailey\u0026quot;, \u0026quot;givennames\u0026quot;: \u0026quot;Bea\u0026quot;, \u0026quot;userid\u0026quot;: \u0026quot;bbailey\u0026quot; }, { \u0026quot;surname\u0026quot;: \u0026quot;Barker\u0026quot;, \u0026quot;givennames\u0026quot;: \u0026quot;Bob\u0026quot;, \u0026quot;userid\u0026quot;: \u0026quot;babarker\u0026quot; } ]  The HTML is\n\u0026lt;div\u0026gt;\u0026lt;form action=\u0026quot;/search\u0026quot; method=\u0026quot;GET\u0026quot; id=\u0026quot;search\u0026quot;\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;searchTerm\u0026quot; name=\u0026quot;searchTerm\u0026quot; value=\u0026quot;\u0026quot; class=\u0026quot;search form-control typeahead\u0026quot; autocomplete=\u0026quot;off\u0026quot;\u0026gt; \u0026lt;/form\u0026gt;\u0026lt;/div\u0026gt;  Here\u0026rsquo;s the Javascript I finally came up with:\nasisJS = function () { var initSearchTypeahead = function () { /* * A hack to keep track of the currently selected userid * when the cursor keys are moved. */ var currentQuery = \u0026quot;\u0026quot;; /* * Cursor moved down the list of suggestions. Keep track * of the current suggestion in currentQuery */ function logCursorChange(ev, suggestion) { if (typeof suggestion == 'undefined' ) { currentQuery = \u0026quot;\u0026quot;; } else { currentQuery = suggestion.userid; } } /* * User triggered a submit, either via the typeahead:submit * or autocomplete event */ function submitSuggestion(ev, suggestion) { $('#searchTerm').val(suggestion.userid); $('#search').submit(); // submit the form } /* * Initialize the search field with the typeahead widget * The source function is hacked so it gets hits if the first * character is in [A-Z] (a name). Otherwise (eg uwid, userid, etc) * it does not. */ $('#searchTerm') .typeahead( { minLength: 1 }, { // Where to get the typeahead suggestions source: function (query, processSync, processAsync) { // If the field has contents (eg \u0026quot;who\u0026quot;) that will be stored // in currentQuery before the user starts to type. Don't want that. currentQuery = \u0026quot;\u0026quot;; if (query.charAt(0) \u0026gt;= \u0026quot;A\u0026quot; \u0026amp;\u0026amp; query.charAt(0) \u0026lt;= \u0026quot;Z\u0026quot;) { // Get the autocomplete; We don't have any synchronous // suggestions. Call the suggestion API to get 10 suggestions // given the contents of the query. The query may contain // spaces, letters, and numbers -- nothing else. Replace // the spaces with _ for http transport. processSync([]); $.get('/api/v2/student/' + query.replace(/ /g, '_') + '/typeahead/10', function (json) { processAsync(json.data); } ); } else { // Not a name; don't do the autocomplete processSync([]); processAsync([]); currentQuery = query; } }, // How to display a suggestion display: function (suggestion) { return suggestion.surname + \u0026quot;, \u0026quot; + suggestion.givennames; }, // Bug in Typeahead. // See https://github.com/twitter/typeahead.js/issues/1232 limit: 20 }) //Catch typeahead events .on('typeahead:select', submitSuggestion) .on('typeahead:autocomplete', submitSuggestion) .on('typeahead:cursorchange', logCursorChange) // Submit the form if the user hits \u0026quot;enter\u0026quot; .on('keydown', function (event) { if (event.which === 13) { if (currentQuery === '') { // Trigger the default (first) suggestion $('.tt-suggestion:first-child').trigger('click'); } else { // The suggestion they chose with arrow keys $('#searchTerm').val(currentQuery); $('#search').submit(); // submit the form } } }) ; // Select any text already in the textbox (eg from error handling) // when the page loads. $('#searchTerm').focus().select(); }; return { initSearchTypeahead: initSearchTypeahead }; } ();  There you have it; hope it\u0026rsquo;s been helpful!\n"
},
{
	"uri": "http://example.org/posts/painful-ide-switch/",
	"title": "Painful Ide Switch",
	"tags": [],
	"description": "",
	"content": " I\u0026rsquo;ve been using Eclipse for my Play! + Scala development, but frustration reached the tipping point and I decided to give IDEA a try. It had been highly recommended by fellow developers at a Scala Meetup (now defunct, sadly). The conversion process has been painful, with some hard-won lessons to report.\nSo, what drove me around the bend with Eclipse? One more bout with it reporting many false positive compilation errors with no easy way to reset things that I could find. SBT would give a completely clean compile; Eclipse would report dozens of errors spread over many, many files. That, and I can be a sucker for new toys.\nIDEA Installation These comments are based on IDEA version 14.1.3 and the Scala plugin 1.5.1 back in May, 2015.\nThe IDEA installation was painful. Here\u0026rsquo;s what I learned:\n Out of date documentation: There is a lot of documentation on the IDEA web site; much of it woefully out of date. For example, a Google search for \u0026ldquo;intellij idea scala play\u0026rdquo; landed me at a features page touting IDEA 13 with links to a tutorial posted in 2013. As the comments at the bottom of the page atest, it\u0026rsquo;s not applicable.\nIf I had landed at this features overview instead, things would have been somewhat less rocky.\n Ultimate Edition required: Working with Play! requires the Ultimate Edition. This tidbit is well hidden. This Play! plugin page, for example, touts support for templates, routes files, etc. No where does it mention that the Community Edition won\u0026rsquo;t work and the download button at the bottom offers both versions, implying that either will work. The linked tutorial doesn\u0026rsquo;t mention it either.\nIt is found on the Scala plugin blog. It\u0026rsquo;s the last sentence of a paragraph that you need to scroll to see.\n Run Play2 App may or may not appear in the context menu, as the documentation on the Play! website and the IntelliJ tutorial indicate. I needed to create a run configuration on my own, first:\n Go to \u0026ldquo;Run \u0026ndash;\u0026gt; Edit Configurations\u0026hellip;\u0026rdquo; Hit the \u0026ldquo;+\u0026rdquo; sign and choose \u0026ldquo;Play2 App\u0026rdquo; from the drop-down. Give it a name and accept the defaults.  I still don\u0026rsquo;t find it in the context menu, but it does appear in the Run menu.\n  In retrospect, these are little things. At the time, however, they were confusing and chewed up time I could have better spent elsewhere.\nExperience I\u0026rsquo;m still getting used to IDEA, but here are some initial observations:\n IDEA has a number of code-smell filters (\u0026ldquo;inspections\u0026rdquo;). Some of them led to code improvements. I wish the hover that describes the problem wasn\u0026rsquo;t so sensitive. It disappears quite easily. There are some false positive type errors \u0026ndash; the same thing that drove me around the bend with Eclipse. So far they are isolated cases rather than the whole system going bonkers as sometimes happened in Eclipse. I like nested helper functions. The Eclipse Outline view shows them; IDEA\u0026rsquo;s Structure view (the closest equivalent) does not. IDEA detects as soon as I use something that hasn\u0026rsquo;t been imported. So far it\u0026rsquo;s made good guesses when it offers to automatically add the import. It seems snappier for editing, but slower than SBT for compiling.   "
},
{
	"uri": "http://example.org/posts/postgres-enums-and-anorm-pt2/",
	"title": "Postgres Enums and Anorm, Part 2",
	"tags": [],
	"description": "",
	"content": "I went to implement my enumerations discoveries as chronicalled in Postgres Enums and Anorm and realized anew something that had niggled away in the back of my brain: I\u0026rsquo;m working with data from a legacy database and most of the enumerations are indecipherable. Many of the enumerations are like this:\nCREATE TYPE _quest.quest_instruction_mode AS ENUM ('P', 'CO');  where \u0026lsquo;P\u0026rsquo; stands for (as far as we can tell!) \u0026ldquo;in-Person\u0026rdquo; and \u0026lsquo;CO\u0026rsquo; stands for \u0026ldquo;Course-Online\u0026rdquo;.\nSo naturally, I\u0026rsquo;d like an intelligible Scala enumeration such as\nobject InstructionMode extends DbEnum { type InstructionMode = Value val InPerson = Value(\u0026quot;P\u0026quot;) val Online = Value(\u0026quot;CO\u0026quot;) }  But here\u0026rsquo;s the rub: println(InstructionMode.Online) still prints the indecipherable CO.\nThe goals I\u0026rsquo;m pursuing are:\n Easy interoperability between Posgres enumerations and Scala enumerations. Printing meaningful values from my program rather than the obscure codes kept in the database. Minimal code duplication or bloat.  Here\u0026rsquo;s my solution. As in my previous post, I\u0026rsquo;m adding a common superclass to my enumerations that itself extends Scala\u0026rsquo;s Enumeration class. The difference this time is that I\u0026rsquo;ve defined an abstract type, myType, and an abstract list that will contain the codes actually used in the database. This allows me to do almost all of the work in the superclass, provided I have one function: unapply takes a string (the one stored in the database) and returns a value from the Scala enumeration.\nA typical Scala enumeration now looks like this:\nobject InstructionMode extends DbEnum { type InstructionMode = Value val InPerson, Online = Value protected type myType = Value protected val dbValues = Array(\u0026quot;P\u0026quot;, \u0026quot;CO\u0026quot;) protected def unapply(s: String): myType = InstructionMode(dbValues.indexOf(s)) }  Notes:\n Line 1 extends DbEnum rather than Enumeration. Thanks to line 4, printing the enumeration\u0026rsquo;s values will give a meaningful result, either \u0026ldquo;InPerson\u0026rdquo; or \u0026ldquo;Online\u0026rdquo;. Line 6 defines the abstract type we\u0026rsquo;ll need in DbEnum. This line is the same in every enum but is needed because Value is different for every enum. Line 7 defines the values actually contained in the database. They need to be in the same order as the values specified in line 4. Line 8 is the unapply function. In all of my cases, it\u0026rsquo;s exactly as shown here except for the obvious substitution for InstructionMode.  The requirement that the order of values in lines 4 and 7 match is a problem, in my mind. There\u0026rsquo;s no question that this can be a source of bugs. But I\u0026rsquo;m out of ideas for how to improve it. If you have some, please comment! I\u0026rsquo;d also appreciate insight into how the name InPerson is captured and put into a map in the Enumeration class. There\u0026rsquo;s still something going on there that I don\u0026rsquo;t understand but I\u0026rsquo;d like to!\nFinally, the code for DbEnum is:\nabstract class DbEnum extends Enumeration { protected type myType \u0026lt;: Enumeration#Value protected val dbValues: Array[String] protected def unapply(s: String): myType /** * Create an implicit to help with converting this Scala enum into the equivalent * Postgres enum. */ implicit val toStatement = new ToStatement[myType] { def set(s: java.sql.PreparedStatement, index: Int, aValue: myType): Unit = { s.setObject(index, dbValues(aValue.id), java.sql.Types.OTHER) } } /** * Convert a database enumeration to a Scala enumeration. * @param convert A conversion function from a string (the value received from the database) to E (the Scala enum). */ implicit def enumToType(implicit m: Manifest[myType]): Column[myType] = Column { (value, meta) =\u0026gt; val MetaDataItem(qualified, nullable, clazz) = meta try { val s = value.asInstanceOf[String] eitherToError(Right(unapply(s))): MayErr[SqlRequestError, myType] } catch { case e: Exception =\u0026gt; eitherToError(Left(TypeDoesNotMatch(\u0026quot;Cannot convert \u0026quot; + value + \u0026quot;:\u0026quot; + value.asInstanceOf[AnyRef].getClass + \u0026quot; to \u0026quot; + m.runtimeClass.getSimpleName + \u0026quot; for column \u0026quot; + qualified))) } } /** * Create a json Reads to read instances of this enumeration from JSON. */ implicit val reads = new Reads[myType] { def reads(json: JsValue): JsResult[myType] = json match { case s: JsString =\u0026gt; val enum = unapply(s.value) JsSuccess(enum) case x =\u0026gt; JsError(s\u0026quot;Expected a string; got $x.\u0026quot;) } } }   Lines 3-5 define the abstract members that need to be defined in each of the individual enumerations. The definitions of toStatement and enumToType are very much the same as in the previous post except that with the new definition of myType we have all the information to move everything into DbEnum. This implementation contains a bonus: Lines 40-47 contain a function that reads the enumeration from a json blob. That\u0026rsquo;s also central to how I\u0026rsquo;m dealing with my database and will, no doubt, be the subject of a future post.  That\u0026rsquo;s it! Enjoy!\n"
},
{
	"uri": "http://example.org/posts/anorm-without-play/",
	"title": "Using Anorm without Play",
	"tags": [],
	"description": "Using Anorm without the Play! framework.",
	"content": " Ever want to use Anorm to access a database without all the overhead of Play?\nI did in my previous post where I played with Postgres enumerations. Here\u0026rsquo;s the code I used.\nIt has a couple of features:\n It reads the .pg_service.conf and .pgpass files from your home directory to find a service definition and the appropriate passwords to use for the connection. This keeps passwords and such out of your code and out of your repository. It mimics the DB class in Anorm to provide a database connection that you can then use with Anorm.  DB class The DB class provides three methods: two that get a connection and one that mimics withConnection (scaladoc). withConnection is the one I use the most (by far) because it handles closing the connection.\nDB assumes the postgres driver is available in the class path and uses PgService (see below) to get the connection data.\nTypical usage is as follows:\nval db = DB(\u0026quot;local_dev\u0026quot;) db.withConnection { implicit conn =\u0026gt; val sql = SQL\u0026quot;\u0026quot;\u0026quot;insert into _oat.test_enum (note_category, sort_order) VALUES (${NoteCategory.Advisor}, ${SortOrder.Ascending}) RETURNING id\u0026quot;\u0026quot;\u0026quot; val id = sql.as(anorm.SqlParser.scalar[Long].singleOpt) }  The \u0026ldquo;local_dev\u0026rdquo; that is passed to the DB constructor is the name of the postgres service to find in the .pg_service.conf file.\nAnd, here\u0026rsquo;s the code for DB:\npackage oatLib.db import java.sql.DriverManager import java.sql.Connection /** * Lots of this is stolen from Play. */ case class DB(service:String) { private val pgService = PgService(service) private val url = s\u0026quot;jdbc:postgresql://${pgService.host}:${pgService.port}/${pgService.dbname}\u0026quot; private val user = pgService.user private val password = pgService.password Class.forName(\u0026quot;org.postgresql.Driver\u0026quot;).newInstance /** * Retrieves a JDBC connection. * * Don't forget to release the connection at some point by calling close(). * * @return a JDBC connection * @throws an error if the required data source is not registered */ def getConnection(): Connection = { var props = new java.util.Properties(); props.setProperty(\u0026quot;user\u0026quot;, user); props.setProperty(\u0026quot;password\u0026quot;, password); DriverManager.getConnection(url, props) } /** * Retrieves a JDBC connection. * * Don't forget to release the connection at some point by calling close(). * * @param autocommit when `true`, sets this connection to auto-commit * @return a JDBC connection * @throws an error if the required data source is not registered */ def getConnection(autocommit: Boolean = true): Connection = { val connection = this.getConnection connection.setAutoCommit(autocommit) connection } /** * Execute a block of code, providing a JDBC connection. The connection and all created statements are * automatically released. * * @param name The datasource name. * @param block Code block to execute. */ def withConnection[A](block: Connection ⇒ A): A = { val connection = getConnection try { block(connection) } finally { connection.close() } } }  PgService class The apply method looks in your home directory for the .pg_service.conf and .pgpass files. The postgres programs that use .pgpass have a sophisticated matching algorithm to choose the specific password required based on the database, user, port, etc. I doubt that I\u0026rsquo;ve completely reverse engineered that algorithm, but I believe this comes pretty close.\npackage oatLib.db import scala.io.{ Source } /** * Read the service information from the account's pg_service.conf * and pgpass files. * * It assumes they're are ~/.pg_service.conf and ~/.pgpass. * */ case class PgService(service: String, host: String, port: Int, dbname: String, user: String, password: String) object PgService { /** * Get the details for the named service from the combination of * the service source (svcFile) and the password source (pwdFile). */ def apply(service: String, svcFile: Source, pwdFile: Source): PgService = { def getService: Map[String, String] = { // Suck in the services file, get rid of services before the one // we want, take the one we want, turn it into a map of key-value // pairs. val allSvc = svcFile.getLines.toList val dropLeadingSvc = allSvc.dropWhile(line ⇒ line != s\u0026quot;[$service]\u0026quot;) .dropWhile(line ⇒ line == s\u0026quot;[$service]\u0026quot;) val svcDef = dropLeadingSvc.takeWhile(line ⇒ line.matches(\u0026quot;[^=]+=[^=]+\u0026quot;)) val svcDef2 = svcDef.map(line ⇒ line.split('=')).map(a ⇒ (a(0), a(1))) svcDef2.toMap } val props = getService if (props.isEmpty) { throw new Exception(s\u0026quot;Unable to find a service configuration for $service\u0026quot;) } val host = props(\u0026quot;host\u0026quot;) val port = props(\u0026quot;port\u0026quot;).toInt val dbname = props(\u0026quot;dbname\u0026quot;) val user = props(\u0026quot;user\u0026quot;) val pwCandidates = pwdFile.getLines.toList .filter(_.matches(s\u0026quot;^([^:]*:){0}($host|\\\\*):.*\u0026quot;)) // matches host .filter(_.matches(s\u0026quot;^([^:]*:){1}($port|\\\\*):.*\u0026quot;)) // matches port .filter(_.matches(s\u0026quot;^([^:]*:){2}($dbname|\\\\*):.*\u0026quot;)) // matches dbname .filter(_.matches(s\u0026quot;^([^:]*:){3}($user|\\\\*):.*\u0026quot;)) // matches user if (pwCandidates.isEmpty) { throw new Exception(s\u0026quot;Unable to find a password for $host:$port:$dbname:$user\u0026quot;) } val password = pwCandidates.headOption.map(_.split(':')(4)).getOrElse(\u0026quot;\u0026quot;) new PgService(service, host, port, dbname, user, password) } /** * Get the details for the named service from the default config * files (~/.pg_service.conf and ~/.pgpass). */ def apply(service: String): PgService = apply(service, Source.fromFile(sys.env(\u0026quot;HOME\u0026quot;) + \u0026quot;/.pg_service.conf\u0026quot;), Source.fromFile(sys.env(\u0026quot;HOME\u0026quot;) + \u0026quot;/.pgpass\u0026quot;)) }  That\u0026rsquo;s it! Enjoy!\n"
},
{
	"uri": "http://example.org/posts/postgres-enums-anorm/",
	"title": "Postgres Enums and Anorm",
	"tags": [],
	"description": "How to marry enumerations in a Postgres database with a Scala program via the Anorm database access library.",
	"content": " Types are a wonderful thing in programming languages. It\u0026rsquo;s the main reason I\u0026rsquo;m using Scala. Having the compiler do a proof that at least part of my program is correct is a huge advantage over a dynamically typed language.\nDatabases can also make use of types \u0026ndash; with similar advantages. In my current project we\u0026rsquo;ve been receiving data from a database that does not use types or other constraints that are the hallmark of modern database design. What a mess! Tables with invalid values, or columns that are never null but nulls are nevertheless allowed, or a column that allows nulls but represents them as either the empty string or a string with one space in it rather than good \u0026lsquo;ole null.\nThis blog post considers how to marry enumerations in a Postgres database with a Scala program via the Anorm database access library.\n Spoiler: This is not what I actually implemented. After you read this, be sure to read the follow-up\n Defining Enumerations Let\u0026rsquo;s start with defining enumerations. The following SQL does it in Postgres:\nAside: You\u0026rsquo;ll note a couple of oddities in the SQL. They\u0026rsquo;re vestiages of the project I\u0026rsquo;m working on. _oat is the database schema I use most frequently. std_note_category and oat_sort_order are actual enums from my current project.\nCREATE TYPE _oat.std_note_category AS ENUM ('Auto', 'Advisor', 'CourseEntry'); CREATE TYPE _oat.oat_sort_order AS ENUM ('ASC', 'DESC');  We can create a quick test table with\nCREATE TABLE _oat.test_enum ( id SERIAL, note_category _oat.std_note_category not null, sort_order _oat.oat_sort_order );  Note that one of columns is nullable, the other is not.\nThe database enumeration is mirrored by two Scala enumerations. The first one uses names that match the values in the database. The second one uses more descriptive names.\nobject NoteCategory extends Enumeration { type NoteCategory = Value val Auto, Advisor, CourseEntry = Value } object SortOrder extends Enumeration { type SortOrder = Value val Ascending = Value(\u0026quot;ASC\u0026quot;) val Descending = Value(\u0026quot;DESC\u0026quot;) }  First Attempt: casting in the queries We can covert back and forth between the Scala enumerations and the database enumerations, but it\u0026rsquo;s painful. Works like this:\ndb.withConnection { implicit conn =\u0026gt; // Delete everything from the table SQL\u0026quot;\u0026quot;\u0026quot;truncate _oat.test_enum\u0026quot;\u0026quot;\u0026quot;.execute() // Insert one of each val sql = SQL\u0026quot;\u0026quot;\u0026quot;insert into _oat.test_enum (note_category, sort_order) VALUES (${NoteCategory.Advisor.toString}::_oat.std_note_category, ${SortOrder.Ascending.toString}::_oat.oat_sort_order ) RETURNING id\u0026quot;\u0026quot;\u0026quot; val id = sql.as(anorm.SqlParser.scalar[Long].singleOpt) // Read them back and verify val r = SQL\u0026quot;\u0026quot;\u0026quot;select * from _oat.test_enum where id = ${id}\u0026quot;\u0026quot;\u0026quot;.apply().head val (nc, so) = (r[String](\u0026quot;note_category\u0026quot;), r[Option[String]](\u0026quot;sort_order\u0026quot;)) assert(NoteCategory.withName(nc) == NoteCategory.Advisor) assert(SortOrder.withName(so.get) == SortOrder.Ascending) }  The objections to this code include:\n The call to toString in lines 9 and 10. The explicit casts required in those same lines. Reading the values back again as strings in line 18 and 19. Explicitly converting the strings to enums in lines 20 and 21.  Obviously, we want to do better.\nBut before we dive into improving, a couple of things to note:\n withName (lines 20, 21) converts a string like \u0026ldquo;Auto\u0026rdquo; into the corresponding enumeration value. In line 19 we use Option[String] because the column is nullable.  Second Attempt: Using ToStatement and a Column converter Anorm uses implicit functions to assist in converting to and from SQL statements. We\u0026rsquo;ll start with the ToStatement, which allows us to embed Scala enumerations in queries easily. We need a couple of functions in each Scala enumeration we write, so put createEnumToStatement in a new superclass and then change the enumerations to extend that class:\nclass DbEnum extends Enumeration { protected def createEnumToStatement[E]() = new ToStatement[E] { def set(s: java.sql.PreparedStatement, index: Int, aValue: E): Unit = { s.setObject(index, aValue.toString, java.sql.Types.OTHER) } } } object NoteCategory extends DbEnum { // Extend DbEnum instead of Enumeration ...\t// same as before implicit val noteCategoryToStatement = createEnumToStatement[NoteCategory]() }  Line 12 is the important one. When you import NoteCategory._ to bring the enum values into scope, this implicit is also brought into scope and used in the SQL statement to interpolate a NoteCategory value into the SQL. The function\u0026rsquo;s name doesn\u0026rsquo;t matter. You\u0026rsquo;ll need a similar line for the other enum, of course.\nLine 12 is what allows us to drop the casts and the explicit calls to toString in the insertion SQL, above. Replace it with the following:\nval sql = SQL\u0026quot;\u0026quot;\u0026quot;insert into _oat.test_enum (note_category, sort_order) VALUES (${NoteCategory.Advisor}, ${SortOrder.Ascending}) RETURNING id\u0026quot;\u0026quot;\u0026quot;  createEnumToStatement creates a new object that sets the appropriate value in a JDBC prepared statement. If you look at the JavaDoc for java.sql.PreparedStatement you\u0026rsquo;ll see many set statements: setInt, setBoolean, setTime, etc. Unfortunately, setEnum is not one of them.\nThe setObject method is interesting. It includes an extra parameter that allows you to specify the type of the value. As you can see in line 4, we use it to pass the enumeration as a string but with the type of java.sql.Types.OTHER. Postgres uses that as a clue to consult the type of the column to do the right thing.\nAdding a Column converter The last step is to automatically convert a Postgres enum read from the database into a Scala enum. This is done with a Column converter. Its use parallels that of createEnumToStatement:\nclass DbEnum extends Enumeration { protected def enumToType[E](convert: String =\u0026gt; E)(implicit m: Manifest[E]): Column[E] = Column { (value, meta) =\u0026gt; val MetaDataItem(qualified, nullable, clazz) = meta try { val s = value.asInstanceOf[String] eitherToError(Right(convert(s))): MayErr[SqlRequestError, E] } catch { case e: Exception =\u0026gt; eitherToError(Left(TypeDoesNotMatch(\u0026quot;Cannot convert \u0026quot; + value + \u0026quot;:\u0026quot; + value.asInstanceOf[AnyRef].getClass + \u0026quot; to \u0026quot; + m.runtimeClass.getSimpleName + \u0026quot;for column \u0026quot; + qualified))) } } // createEnumToStatement, as before } object NoteCategory extends DbEnum { // define enum values and use createEnumToStatement, as before implicit val rowToNoteCategory = enumToType[NoteCategory](NoteCategory.withName) }  Some explanatory comments:\n enumToType is again parameterized by the type of the enum. In line 2 it consumes a function that converts a string (the value read from the database) into a value of type E (the enum). For most enumerations this is simply the withName function that we get for free when defining the enum. And that is, indeed, what\u0026rsquo;s passed in line 23. Things can go wrong in two ways: we might get an unexpected value from the database that can\u0026rsquo;t be converted by withName (probably indicating that your Postgres enum and Scala enum are out of synch) and, if things are really borked, we might not even get a string from the database. Either of these are caught and turned into an error in lines 11-14. If the column should never have a null value, you can wrap enumToType in line 23 with Column.nonNull(enumToType...). This will throw the familiar \u0026ldquo;Unexpected nullable\u0026rdquo; error if a null value is found. If nulls are expected, then read the value as an Option[SortOrder], for example.  Final Comments The test program is self-contained except for the first import line. That\u0026rsquo;s what provides some support code to make the database connection. I\u0026rsquo;ll write that up soon.\nThe other imports are\nimport anorm._ import org.postgresql.util.PGobject import anorm.MayErr._ import java.sql.Connection  That\u0026rsquo;s it! Enjoy!\n"
},
{
	"uri": "http://example.org/",
	"title": "Hard-Won Intro",
	"tags": [],
	"description": "",
	"content": "I\u0026rsquo;m doing a lot of development in Scala + Play these days. I often come up against a problem with a \u0026ldquo;hard won\u0026rdquo; solution. It might be a fundamental misunderstanding on my part, something I just haven\u0026rsquo;t run into before, or where Googling isn\u0026rsquo;t as helpful as it often is. Regardless, the solution came at some pain to myself. To help make that hard won solution less painful, I\u0026rsquo;m posting here to remind me and to help others.\nI hope you find it useful.\n"
},
{
	"uri": "http://example.org/categories/anorm/",
	"title": "Anorm",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/categories/enumeration/",
	"title": "Enumeration",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/categories/play/",
	"title": "Play",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/categories/postgres/",
	"title": "Postgres",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/posts/",
	"title": "Posts",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/categories/scala/",
	"title": "Scala",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://example.org/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]